<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Architecture Overview - The DAGwood Project Demo</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Interactive demonstration of DAG execution strategies, Rust concepts, and WASM integration">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The DAGwood Project Demo</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ciroque/the-dagwood" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ciroque/the-dagwood/edit/main/docs/demo/src/architecture.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>Before diving into the demos, let's understand how The DAGwood project is architected. This chapter provides a comprehensive overview of the system design, key components, and architectural decisions that make DAGwood a robust workflow orchestration platform.</p>
<h2 id="system-architecture"><a class="header" href="#system-architecture">System Architecture</a></h2>
<h3 id="high-level-architecture"><a class="header" href="#high-level-architecture">High-Level Architecture</a></h3>
<pre><code class="language-mermaid">graph TB
    subgraph "User Interface Layer"
        CLI[CLI Interface]
        Config[YAML Configuration]
    end
    
    subgraph "Core Engine"
        Runtime[Runtime Builder]
        Executor[DAG Executors]
        Validator[Config Validator]
    end
    
    subgraph "Execution Strategies"
        WQ[Work Queue]
        LBL[Level-by-Level]
        Reactive[Reactive]
        Hybrid[Hybrid]
    end
    
    subgraph "Backend Systems"
        Local[Local Backend]
        WASM[WASM Backend]
        Future[Future Backends]
    end
    
    subgraph "Processor Layer"
        LP[Local Processors]
        WP[WASM Processors]
        Custom[Custom Processors]
    end
    
    CLI --&gt; Runtime
    Config --&gt; Validator
    Validator --&gt; Runtime
    Runtime --&gt; Executor
    Executor --&gt; WQ
    Executor --&gt; LBL
    Executor --&gt; Reactive
    Executor --&gt; Hybrid
    WQ --&gt; Local
    WQ --&gt; WASM
    LBL --&gt; Local
    LBL --&gt; WASM
    Local --&gt; LP
    WASM --&gt; WP
</code></pre>
<h3 id="core-components"><a class="header" href="#core-components">Core Components</a></h3>
<h4 id="1-configuration-system"><a class="header" href="#1-configuration-system">1. Configuration System</a></h4>
<p>The configuration system is the entry point for defining workflows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configuration structure
pub struct Config {
    pub strategy: Strategy,                    // Execution strategy selection
    pub failure_strategy: FailureStrategy,    // Error handling approach
    pub executor_options: ExecutorOptions,    // Runtime configuration
    pub processors: Vec&lt;ProcessorConfig&gt;,     // Processor definitions
}

pub struct ProcessorConfig {
    pub id: String,                           // Unique processor identifier
    pub backend: String,                      // Backend type (local, wasm)
    pub impl_: Option&lt;String&gt;,                // Implementation name
    pub module: Option&lt;String&gt;,               // WASM module path
    pub depends_on: Vec&lt;String&gt;,              // Dependency list
    pub options: HashMap&lt;String, String&gt;,     // Processor-specific options
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>YAML-based</strong>: Human-readable workflow definitions</li>
<li><strong>Validation</strong>: Comprehensive validation with detailed error messages</li>
<li><strong>Dependency Resolution</strong>: Automatic cycle detection and reference validation</li>
<li><strong>Flexible Options</strong>: Processor-specific configuration support</li>
</ul>
<h4 id="2-runtime-builder"><a class="header" href="#2-runtime-builder">2. Runtime Builder</a></h4>
<p>The Runtime Builder creates execution components from configuration using several key design patterns:</p>
<p><strong>Design Patterns Used:</strong></p>
<ul>
<li><strong>Factory Pattern</strong>: Dynamic processor creation based on configuration type</li>
<li><strong>Strategy Pattern</strong>: Pluggable execution strategies (WorkQueue, Level-by-Level, Reactive)</li>
<li><strong>Builder Pattern</strong>: Fluent configuration construction from YAML</li>
</ul>
<p>The Runtime Builder transforms YAML configuration into executable components, handling processor instantiation, executor selection, and failure strategy configuration.</p>
<h4 id="3-dag-execution-engine"><a class="header" href="#3-dag-execution-engine">3. DAG Execution Engine</a></h4>
<p>The execution engine coordinates workflow execution across different strategies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait DagExecutor: Send + Sync {
    async fn execute_with_strategy(
        &amp;self,
        processors: HashMap&lt;String, Box&lt;dyn Processor&gt;&gt;,
        dependency_graph: DependencyGraph,
        entry_points: EntryPoints,
        input: ProcessorRequest,
        pipeline_metadata: PipelineMetadata,
        failure_strategy: FailureStrategy,
    ) -&gt; Result&lt;(ExecutionResults, PipelineMetadata), ExecutionError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Responsibilities:</strong></p>
<ul>
<li><strong>Dependency Resolution</strong>: Topological ordering and cycle detection</li>
<li><strong>Concurrency Management</strong>: Parallel execution with configurable limits</li>
<li><strong>Error Handling</strong>: Comprehensive failure strategies</li>
<li><strong>Metadata Tracking</strong>: Complete audit trail and context preservation</li>
</ul>
<h2 id="execution-strategies"><a class="header" href="#execution-strategies">Execution Strategies</a></h2>
<h3 id="work-queue-strategy"><a class="header" href="#work-queue-strategy">Work Queue Strategy</a></h3>
<p>The Work Queue strategy maximizes parallelism through dependency counting:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WorkQueueExecutor {
    max_concurrency: usize,
}

impl WorkQueueExecutor {
    async fn execute_dag(&amp;self, /* parameters */) -&gt; Result&lt;ExecutionResults, ExecutionError&gt; {
        // 1. Initialize dependency counts
        let mut dependency_counts = self.calculate_dependency_counts(&amp;graph);
        
        // 2. Queue processors with no dependencies
        let mut ready_queue = self.find_ready_processors(&amp;dependency_counts);
        
        // 3. Execute with concurrency control
        let semaphore = Arc::new(Semaphore::new(self.max_concurrency));
        
        while !ready_queue.is_empty() || !active_tasks.is_empty() {
            // Spawn tasks up to concurrency limit
            while !ready_queue.is_empty() &amp;&amp; semaphore.available_permits() &gt; 0 {
                let processor_id = ready_queue.pop_front().unwrap();
                let task = self.spawn_processor_task(processor_id, &amp;semaphore);
                active_tasks.push(task);
            }
            
            // Wait for task completion and update dependencies
            let (processor_id, result) = select_completed_task(&amp;mut active_tasks).await;
            self.update_dependencies(processor_id, &amp;mut dependency_counts, &amp;mut ready_queue);
        }
        
        Ok(results)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li><strong>Maximum Parallelism</strong>: Executes processors as soon as dependencies are satisfied</li>
<li><strong>Dynamic Scheduling</strong>: Adapts to irregular DAG structures</li>
<li><strong>Memory Efficient</strong>: Uses dependency counting instead of level computation</li>
<li><strong>Best For</strong>: Complex DAGs with irregular dependency patterns</li>
</ul>
<h3 id="level-by-level-strategy"><a class="header" href="#level-by-level-strategy">Level-by-Level Strategy</a></h3>
<p>The Level-by-Level strategy executes processors in topological levels:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LevelByLevelExecutor {
    max_concurrency: usize,
}

impl LevelByLevelExecutor {
    async fn execute_dag(&amp;self, /* parameters */) -&gt; Result&lt;ExecutionResults, ExecutionError&gt; {
        // 1. Compute topological levels
        let levels = self.compute_topological_levels(&amp;graph)?;
        
        // 2. Execute level by level
        for level in levels {
            // Execute all processors in current level concurrently
            let level_tasks: Vec&lt;_&gt; = level.into_iter()
                .map(|processor_id| self.spawn_processor_task(processor_id))
                .collect();
            
            // Wait for entire level to complete
            let level_results = futures::future::join_all(level_tasks).await;
            
            // Process results and handle errors
            for result in level_results {
                self.process_result(result)?;
            }
        }
        
        Ok(results)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li><strong>Predictable Execution</strong>: Clear level-by-level progression</li>
<li><strong>Simpler State Management</strong>: No complex dependency tracking during execution</li>
<li><strong>Level Parallelism</strong>: Full parallelism within each level</li>
<li><strong>Best For</strong>: Regular DAGs with clear hierarchical structure</li>
</ul>
<h3 id="reactive-strategy"><a class="header" href="#reactive-strategy">Reactive Strategy</a></h3>
<p>The Reactive strategy uses event-driven execution for maximum responsiveness:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ReactiveExecutor {
    max_concurrency: usize,
}

impl ReactiveExecutor {
    async fn execute_dag(&amp;self, /* parameters */) -&gt; Result&lt;ExecutionResults, ExecutionError&gt; {
        // 1. Create event channels for each processor
        let (senders, receivers) = self.create_event_channels(&amp;graph);
        
        // 2. Spawn processor tasks that wait for dependency events
        for processor_id in graph.processors() {
            let task = self.spawn_reactive_task(processor_id, &amp;receivers, &amp;senders);
            active_tasks.insert(processor_id, task);
        }
        
        // 3. Trigger entry point processors
        for entry_point in entry_points {
            senders[&amp;entry_point].send(ProcessorEvent::Ready)?;
        }
        
        // 4. Event-driven execution - processors notify dependents when complete
        while !active_tasks.is_empty() {
            let (processor_id, result) = select_completed_task(&amp;mut active_tasks).await;
            self.notify_dependents(processor_id, &amp;result, &amp;senders).await;
        }
        
        Ok(results)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li><strong>Event-Driven</strong>: Processors react immediately to dependency completion</li>
<li><strong>Maximum Responsiveness</strong>: No waiting for levels or queue processing</li>
<li><strong>Real-Time Execution</strong>: Optimal for low-latency requirements</li>
<li><strong>Complex State Management</strong>: Sophisticated event coordination</li>
<li><strong>Best For</strong>: I/O-bound processors, real-time workflows, irregular DAGs</li>
</ul>
<h3 id="canonical-payload-architecture"><a class="header" href="#canonical-payload-architecture">Canonical Payload Architecture</a></h3>
<p>All three strategies use a canonical payload approach for data flow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CanonicalPayloadArchitecture {
    // Single source of truth for data
    canonical_payload: Arc&lt;Mutex&lt;Vec&lt;u8&gt;&gt;&gt;,
    
    // Processor classification
    transform_processors: Vec&lt;String&gt;,  // Modify canonical payload
    analyze_processors: Vec&lt;String&gt;,    // Add metadata only
}

impl CanonicalPayloadArchitecture {
    async fn execute_processor(&amp;self, processor: &amp;dyn Processor) -&gt; ProcessorResponse {
        match processor.declared_intent() {
            ProcessorIntent::Transform =&gt; {
                // Transform processors modify the canonical payload
                let mut payload = self.canonical_payload.lock().await;
                let result = processor.process(&amp;*payload).await?;
                if let Some(new_payload) = result.next_payload {
                    *payload = new_payload;
                }
                result
            },
            ProcessorIntent::Analyze =&gt; {
                // Analyze processors only add metadata
                let payload = self.canonical_payload.lock().await;
                processor.process(&amp;*payload).await
            },
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li><strong>Data Consistency</strong>: Single source of truth prevents data races</li>
<li><strong>Clear Semantics</strong>: Transform vs Analyze intent is explicit</li>
<li><strong>Metadata Preservation</strong>: Analysis results are preserved without payload modification</li>
<li><strong>Race Condition Prevention</strong>: Eliminates non-deterministic execution</li>
</ul>
<h2 id="backend-architecture"><a class="header" href="#backend-architecture">Backend Architecture</a></h2>
<h3 id="local-backend"><a class="header" href="#local-backend">Local Backend</a></h3>
<p>The local backend provides built-in processors with factory-based creation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LocalProcessorFactory;

impl LocalProcessorFactory {
    pub fn create_processor(config: &amp;ProcessorConfig) -&gt; Result&lt;Box&lt;dyn Processor&gt;, ProcessorError&gt; {
        let impl_name = config.impl_.as_deref().unwrap_or("stub");
        
        match impl_name {
            "change_text_case_upper" =&gt; Ok(Box::new(ChangeTextCaseProcessor::new(TextCase::Upper))),
            "token_counter" =&gt; Ok(Box::new(TokenCounterProcessor::new(config.options.clone()))),
            "word_frequency_analyzer" =&gt; Ok(Box::new(WordFrequencyProcessor::new())),
            "prefix_suffix_adder" =&gt; Ok(Box::new(PrefixSuffixProcessor::new(config.options.clone()))),
            _ =&gt; Err(ProcessorError::UnknownImplementation { name: impl_name.to_string() }),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Available Processors:</strong></p>
<ul>
<li><strong>Text Transformation</strong>: Case conversion, reversal, prefix/suffix addition</li>
<li><strong>Text Analysis</strong>: Token counting, word frequency analysis</li>
<li><strong>Extensible</strong>: Easy to add new processors through factory pattern</li>
</ul>
<h3 id="wasm-backend"><a class="header" href="#wasm-backend">WASM Backend</a></h3>
<p>The WASM backend provides secure, sandboxed execution:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WasmProcessor {
    engine: wasmtime::Engine,
    module: wasmtime::Module,
    store: wasmtime::Store&lt;WasmState&gt;,
}

impl WasmProcessor {
    pub fn new(module_path: &amp;str) -&gt; Result&lt;Self, WasmError&gt; {
        // Create WASM engine with security configuration
        let mut config = wasmtime::Config::new();
        config.wasm_simd(false);           // Disable SIMD for security
        config.wasm_bulk_memory(false);    // Disable bulk memory operations
        config.consume_fuel(true);         // Enable fuel consumption for limits
        
        let engine = wasmtime::Engine::new(&amp;config)?;
        let module = wasmtime::Module::from_file(&amp;engine, module_path)?;
        
        // Create store with resource limits
        let mut store = wasmtime::Store::new(&amp;engine, WasmState::new());
        store.limiter(|state| &amp;mut state.limiter);  // Apply resource limits
        
        Ok(WasmProcessor { engine, module, store })
    }
    
    async fn execute_wasm(&amp;mut self, input: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, WasmError&gt; {
        // Create instance with imported functions
        let instance = wasmtime::Instance::new(&amp;mut self.store, &amp;self.module, &amp;[])?;
        
        // Get exported functions
        let process_func = instance.get_typed_func::&lt;(i32,), i32&gt;(&amp;mut self.store, "process")?;
        let allocate_func = instance.get_typed_func::&lt;i32, i32&gt;(&amp;mut self.store, "allocate")?;
        let deallocate_func = instance.get_typed_func::&lt;(i32, i32), ()&gt;(&amp;mut self.store, "deallocate")?;
        
        // Allocate memory in WASM module
        let input_ptr = allocate_func.call(&amp;mut self.store, input.len() as i32)?;
        
        // Copy input data to WASM memory
        let memory = instance.get_memory(&amp;mut self.store, "memory")
            .ok_or(WasmError::MemoryNotFound)?;
        memory.write(&amp;mut self.store, input_ptr as usize, input)?;
        
        // Call WASM function
        let result_ptr = process_func.call(&amp;mut self.store, input_ptr)?;
        
        // Read result from WASM memory
        let result = self.read_cstring_from_memory(&amp;mut self.store, &amp;memory, result_ptr)?;
        
        // Clean up allocated memory
        deallocate_func.call(&amp;mut self.store, (input_ptr, input.len() as i32))?;
        
        Ok(result.into_bytes())
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Security Features:</strong></p>
<ul>
<li><strong>Complete Sandboxing</strong>: WASM modules cannot access host system</li>
<li><strong>Resource Limits</strong>: CPU and memory consumption limits</li>
<li><strong>Controlled Memory Access</strong>: Safe memory management across boundaries</li>
<li><strong>Capability-Based Security</strong>: Explicit permissions for host access</li>
</ul>
<h2 id="data-flow-architecture"><a class="header" href="#data-flow-architecture">Data Flow Architecture</a></h2>
<h3 id="requestresponse-flow"><a class="header" href="#requestresponse-flow">Request/Response Flow</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Data flow through the system
pub struct DataFlow {
    // 1. Input Processing
    input: ProcessorRequest {
        payload: Vec&lt;u8&gt;,  // Raw input data
    },
    
    // 2. Pipeline Metadata
    pipeline_metadata: PipelineMetadata {
        metadata: HashMap&lt;String, ProcessorMetadata&gt;,  // Accumulated context
    },
    
    // 3. Processor Response
    response: ProcessorResponse {
        outcome: Option&lt;Outcome&gt;,           // Transform result or analysis
        metadata: Option&lt;PipelineMetadata&gt;, // Additional context
    },
    
    // 4. Final Results
    results: ExecutionResults {
        processor_results: HashMap&lt;String, ProcessorResponse&gt;,
        final_metadata: PipelineMetadata,
    },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="metadata-system"><a class="header" href="#metadata-system">Metadata System</a></h3>
<p>The metadata system provides comprehensive context tracking:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MetadataSystem {
    // Namespace isolation prevents collisions
    namespaces: HashMap&lt;String, ProcessorMetadata&gt;,
}

impl MetadataSystem {
    pub fn merge_metadata(&amp;mut self, new_metadata: PipelineMetadata) {
        for (processor_id, processor_metadata) in new_metadata.metadata {
            // Collision-resistant merging
            let namespace = format!("{}_{}", processor_id, self.generate_unique_suffix());
            self.namespaces.insert(namespace, processor_metadata);
        }
    }
    
    pub fn get_processor_context(&amp;self, processor_id: &amp;str) -&gt; Option&lt;&amp;ProcessorMetadata&gt; {
        // Retrieve processor-specific context
        self.namespaces.get(processor_id)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Features:</strong></p>
<ul>
<li><strong>Namespace Isolation</strong>: Prevents metadata key collisions</li>
<li><strong>Context Preservation</strong>: Complete audit trail of execution</li>
<li><strong>Hierarchical Structure</strong>: Nested metadata for complex workflows</li>
<li><strong>Serializable</strong>: Protobuf-based for efficient storage and transmission</li>
</ul>
<h2 id="error-handling-architecture"><a class="header" href="#error-handling-architecture">Error Handling Architecture</a></h2>
<h3 id="comprehensive-error-types"><a class="header" href="#comprehensive-error-types">Comprehensive Error Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
pub enum ExecutionError {
    #[error("Configuration validation failed: {message}")]
    ConfigurationError { message: String },
    
    #[error("Processor {processor_id} failed: {source}")]
    ProcessorError { 
        processor_id: String, 
        #[source] source: ProcessorError 
    },
    
    #[error("Dependency cycle detected: {cycle:?}")]
    CyclicDependencyError { cycle: Vec&lt;String&gt; },
    
    #[error("WASM execution failed: {source}")]
    WasmError { #[source] source: WasmError },
}

#[derive(Debug, thiserror::Error)]
pub enum ProcessorError {
    #[error("Validation failed: {message}")]
    ValidationError { message: String },
    
    #[error("Unknown implementation: {name}")]
    UnknownImplementation { name: String },
    
    #[error("WASM module error: {message}")]
    WasmModuleError { message: String },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="failure-strategies"><a class="header" href="#failure-strategies">Failure Strategies</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum FailureStrategy {
    FailFast,        // Stop on first error
    ContinueOnError, // Continue with remaining processors
    BestEffort,      // Attempt recovery and partial results
}

impl FailureStrategy {
    pub async fn handle_processor_failure(
        &amp;self,
        processor_id: &amp;str,
        error: ProcessorError,
        context: &amp;ExecutionContext,
    ) -&gt; FailureAction {
        match self {
            FailureStrategy::FailFast =&gt; FailureAction::AbortExecution,
            FailureStrategy::ContinueOnError =&gt; FailureAction::SkipProcessor,
            FailureStrategy::BestEffort =&gt; {
                // Attempt recovery or provide default result
                if let Some(recovery) = self.attempt_recovery(processor_id, &amp;error, context).await {
                    FailureAction::UseRecoveryResult(recovery)
                } else {
                    FailureAction::SkipProcessor
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-architecture"><a class="header" href="#performance-architecture">Performance Architecture</a></h2>
<h3 id="concurrency-management"><a class="header" href="#concurrency-management">Concurrency Management</a></h3>
<p>Each executor implements concurrency control using tokio's Semaphore:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From WorkQueueExecutor - actual implementation
impl WorkQueueExecutor {
    async fn execute_with_strategy(/* ... */) -&gt; Result&lt;ExecutionResults, ExecutionError&gt; {
        // Create semaphore for concurrency control
        let semaphore = Arc::new(tokio::sync::Semaphore::new(self.max_concurrency));
        
        // Process work queue with concurrency limits
        while !work_queue.is_empty() {
            // Acquire permit before spawning task
            let permit = semaphore.clone().acquire_owned().await
                .map_err(|_| ExecutionError::InternalError { 
                    message: "Failed to acquire semaphore permit".to_string() 
                })?;
            
            let processor_id = work_queue.pop().unwrap().processor_id;
            
            // Spawn processor task with permit
            let task_handle = tokio::spawn(async move {
                let _permit = permit; // Permit released when task completes
                // Execute processor...
            });
            
            active_tasks.insert(processor_id, task_handle);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Real Implementation Features:</strong></p>
<ul>
<li><strong>Semaphore-based limits</strong>: <code>tokio::sync::Semaphore</code> controls concurrent executions</li>
<li><strong>Permit-based execution</strong>: Tasks acquire permits before running</li>
<li><strong>Automatic cleanup</strong>: Permits released when tasks complete</li>
<li><strong>Configurable concurrency</strong>: <code>max_concurrency</code> parameter sets limits</li>
</ul>
<h3 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h3>
<p>The DAGwood implementation uses several key memory management patterns:</p>
<h4 id="canonical-payload-architecture-1"><a class="header" href="#canonical-payload-architecture-1">Canonical Payload Architecture</a></h4>
<ul>
<li><strong>Single Source of Truth</strong>: One canonical payload flows through the DAG</li>
<li><strong>Transform vs Analyze</strong>: Only Transform processors can modify the canonical payload</li>
<li><strong>Race Condition Prevention</strong>: Eliminates non-deterministic behavior in diamond patterns</li>
<li><strong>Arc&lt;Mutex<T>&gt;</strong>: Thread-safe shared ownership for concurrent access</li>
</ul>
<h4 id="memory-optimization-patterns"><a class="header" href="#memory-optimization-patterns">Memory Optimization Patterns</a></h4>
<ul>
<li><strong>Arc Sharing</strong>: Reference counting for large payloads instead of cloning</li>
<li><strong>Lazy Cloning</strong>: Clone only when ownership transfer is required</li>
<li><strong>Efficient Metadata</strong>: Collision-resistant namespacing for metadata keys</li>
</ul>
<h2 id="extensibility-architecture"><a class="header" href="#extensibility-architecture">Extensibility Architecture</a></h2>
<h3 id="design-patterns-for-extensibility"><a class="header" href="#design-patterns-for-extensibility">Design Patterns for Extensibility</a></h3>
<p>The DAGwood project uses several key patterns to enable extensibility:</p>
<h4 id="factory-pattern"><a class="header" href="#factory-pattern">Factory Pattern</a></h4>
<ul>
<li><strong>Processor Creation</strong>: Dynamic instantiation based on configuration</li>
<li><strong>Backend Abstraction</strong>: Pluggable processor backends (Local, WASM)</li>
<li><strong>Type Safety</strong>: Compile-time guarantees for processor interfaces</li>
</ul>
<h4 id="strategy-pattern"><a class="header" href="#strategy-pattern">Strategy Pattern</a></h4>
<ul>
<li><strong>Execution Strategies</strong>: Pluggable DAG execution algorithms</li>
<li><strong>Failure Handling</strong>: Configurable error handling strategies</li>
<li><strong>Backend Selection</strong>: Runtime selection of processor backends</li>
</ul>
<h4 id="trait-system"><a class="header" href="#trait-system">Trait System</a></h4>
<ul>
<li><strong>Processor Trait</strong>: Common interface for all processor implementations</li>
<li><strong>DagExecutor Trait</strong>: Common interface for execution strategies</li>
<li><strong>Intent Declaration</strong>: Transform vs Analyze processor classification</li>
</ul>
<h2 id="key-architectural-decisions"><a class="header" href="#key-architectural-decisions">Key Architectural Decisions</a></h2>
<h3 id="adr-summary"><a class="header" href="#adr-summary">ADR Summary</a></h3>
<p>The architecture reflects several key decisions documented in the project ADRs:</p>
<ol>
<li><strong>Language Choice (Rust)</strong>: Memory safety, performance, and excellent async support</li>
<li><strong>Canonical Payload</strong>: Single source of truth prevents race conditions</li>
<li><strong>Strategy Pattern</strong>: Pluggable execution strategies for different use cases</li>
<li><strong>WASM Sandboxing</strong>: Security through complete isolation</li>
<li><strong>Protobuf Serialization</strong>: Efficient, cross-language data exchange</li>
<li><strong>Factory Pattern</strong>: Extensible processor creation</li>
<li><strong>Semaphore Concurrency</strong>: Configurable parallelism with resource limits</li>
</ol>
<h3 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ArchitecturalPrinciples {
    // Core principles guiding the design
    safety_first: "Memory safety and security are non-negotiable",
    performance_by_design: "Efficient algorithms and zero-cost abstractions",
    extensibility: "Plugin architecture for custom backends and processors",
    observability: "Complete audit trails and performance metrics",
    simplicity: "Complex internals, simple external interfaces",
    reliability: "Comprehensive error handling and recovery strategies",
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you understand the architecture, you're ready to see it in action! The following demos will show how these components work together to execute real workflows, from simple single-processor tasks to complex multi-backend pipelines.</p>
<p>The architecture provides:</p>
<ul>
<li><strong>Flexibility</strong>: Multiple execution strategies for different use cases</li>
<li><strong>Security</strong>: Complete WASM sandboxing with resource limits</li>
<li><strong>Performance</strong>: Efficient parallel execution with configurable concurrency</li>
<li><strong>Extensibility</strong>: Plugin architecture for custom processors and backends</li>
<li><strong>Reliability</strong>: Comprehensive error handling and recovery mechanisms</li>
</ul>
<hr />
<blockquote>
<p>üèóÔ∏è <strong>Architecture Philosophy</strong>: The DAGwood architecture prioritizes safety, performance, and extensibility. Every component is designed to be both powerful and secure, with clear separation of concerns and well-defined interfaces. This foundation enables complex workflow orchestration while maintaining system reliability and developer productivity.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="introduction.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="01-hello-world.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="introduction.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="01-hello-world.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>



    </div>
    </body>
</html>
