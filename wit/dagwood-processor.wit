// Copyright (c) 2025 Steve Wagner (ciroque@live.com)
// SPDX-License-Identifier: MIT

/// DAGwood WASM Component Interface
/// 
/// This WIT file defines the WebAssembly Interface Types (WIT) specification
/// for DAGwood WASM components. These are low-level WASM modules that export
/// specific functions for data processing within the DAGwood pipeline system.
/// 
/// ## Architecture Overview
/// 
/// ```
/// DAGwood Runtime
///       ↓
/// WasmProcessor (Rust) ← implements Processor trait
///       ↓
/// WASM Component ← exports process(), allocate(), deallocate()
/// ```
/// 
/// The WASM component is a pure WASM module with no knowledge of DAGwood's
/// Processor trait. The WasmProcessor in the DAGwood runtime handles the
/// bridge between the Rust ecosystem and the WASM component.
/// 
/// ## Current Interface (C-style exports)
/// 
/// WASM components currently export three C-style functions:
/// - `process(input_ptr, input_len, output_len_ptr) -> output_ptr`
/// - `allocate(size) -> ptr`
/// - `deallocate(ptr, size)`
/// 
/// ## This WIT Specification
/// 
/// This WIT file provides a formal specification of the current interface:
/// - Documents the existing contract for implementors
/// - Enables tooling and binding generation
/// - Provides foundation for Component Model migration
/// - Maintains exact compatibility with current C-style exports
/// 
/// ## Future Evolution Path (vNext Component Model)
/// 
/// **Current v1.0**: Raw pointer interface optimized for C compatibility and host control
/// ```wit
/// process: func(input-ptr: u32, input-len: u32, output-len-ptr: u32) -> result<u32, processing-error>;
/// ```
/// 
/// **Future vNext**: Direct `list<u8>` interface reducing host boilerplate
/// ```wit
/// process: func(input: list<u8>) -> result<list<u8>, processing-error>;
/// ```
/// 
/// **Migration Benefits**:
/// - **Eliminates Host Boilerplate**: No manual allocate/memcpy/deallocate cycles
/// - **Type Safety**: Component Model handles memory management automatically
/// - **Multi-Language Ergonomics**: Natural `Vec<u8>` in Rust, `[]byte` in Go, etc.
/// - **Backward Compatibility**: Pointer-based components can coexist during transition
/// 
/// **Current Pointer Advantages** (why v1.0 is optimal for now):
/// - **C Ecosystem Compatibility**: Direct FFI with existing C/C++ WASM toolchains
/// - **Memory Control**: Host retains fine-grained control over allocation strategies
/// - **Debugging**: Explicit memory operations aid in troubleshooting
/// - **Performance**: Zero abstraction overhead for memory-sensitive workloads
/// 
/// ## Security Model
/// 
/// - **Complete Sandboxing**: No access to host filesystem, network, or system calls
/// - **Memory Isolation**: Components operate within bounded WASM linear memory
/// - **Resource Limits**: Execution time and memory consumption are bounded
/// - **Input Validation**: All inputs are validated before processing

package dagwood:component@1.0.0;

/// Low-level WASM component interface for data processing
/// 
/// This interface defines the contract for WASM components that process
/// data within DAGwood pipelines. Components are simple, stateless
/// processors that transform input data to output data.
interface processing-node {
    /// Size limits for WASM memory management
    /// These constants define the operational boundaries for safe WASM execution
    const MAX_PAYLOAD_SIZE: u32 = 134217728; // 128MB - reasonable limit for WASM linear memory
    const MAX_ALLOCATION_SIZE: u32 = 67108864; // 64MB - maximum single allocation
    const MIN_ALLOCATION_SIZE: u32 = 1; // Minimum allocation size
    
    /// Error codes for mapping to Rust ProcessingNodeError types
    const ERROR_CODE_VALIDATION: u32 = 1000;
    const ERROR_CODE_RUNTIME: u32 = 2000;
    const ERROR_CODE_INPUT: u32 = 3000;
    const ERROR_CODE_ALLOCATION: u32 = 4000;
    const ERROR_CODE_PROCESSING: u32 = 5000;

    /// Memory allocation errors with error codes for Rust mapping
    variant allocation-error {
        /// Out of memory - cannot allocate requested size
        /// Maps to ProcessingNodeError::CStyleError(AllocationFailed)
        out-of-memory,
        /// Invalid size - zero or excessively large allocation request
        /// Maps to ProcessingNodeError::ValidationError
        invalid-size(u32),
        /// Memory corruption - internal allocator state is corrupted
        /// Maps to ProcessingNodeError::RuntimeError
        memory-corruption,
        /// Invalid pointer - not from a previous allocate() call or already freed
        /// Maps to ProcessingNodeError::CStyleError(AllocationFailed)
        invalid-pointer(u32),
        /// Size mismatch - deallocate size doesn't match original allocation
        /// Maps to ProcessingNodeError::ValidationError
        size-mismatch(u32),
    }
    
    /// Data processing errors with error codes for Rust mapping
    variant processing-error {
        /// Invalid input data (malformed format, etc.)
        /// Maps to ProcessingNodeError::InputError
        invalid-input(string),
        /// Processing logic failed (algorithm error, computation failure)
        /// Maps to ProcessingNodeError::CStyleError(FunctionExecutionFailed)
        processing-failed(string),
        /// Input too large for component to handle
        /// Maps to ProcessingNodeError::ValidationError
        input-too-large(u32),
        /// Unknown/unexpected error for extensibility and opaque binary handling
        /// Maps to ProcessingNodeError::RuntimeError - catches weird formats gracefully
        unknown(string),
    }
    
    /// Main data processing function
    /// 
    /// Processes input data and returns a pointer to output data.
    /// This is a low-level interface that works directly with WASM linear memory.
    /// 
    /// ## Current C-style equivalent:
    /// ```c
    /// uint8_t* process(const uint8_t* input_ptr, uint32_t input_len, uint32_t* output_len);
    /// ```
    /// 
    /// ## Parameters:
    /// - `input-ptr`: Pointer to input data in WASM linear memory (u32 - WASM address space)
    /// - `input-len`: Length of input data in bytes (u32 - matches WASM 32-bit addressing)
    /// - `output-len-ptr`: Pointer to where output length should be written (u32)
    /// 
    /// ## Returns:
    /// - **Success**: Pointer to allocated output data in WASM linear memory
    /// - **Error**: Returns processing-error with mapped error codes
    /// - Caller must call deallocate() to free the returned memory on success
    /// 
    /// ## Error Propagation & Debugging:
    /// - **Bindings Behavior**: Language bindings (Rust, etc.) map `Err` results to null pointer (0) + error logging
    /// - **Consistency Tip**: Components should write `*output-len-ptr = 0` on error for consistent host-side handling
    /// - **Rust Integration**: Errors chain cleanly with `?` operator in ProcessingNodeExecutor implementations
    /// - **Opaque Binary Safety**: Use `unknown(string)` for unexpected binary formats that can't be categorized
    /// 
    /// ## Simplified Memory Flow:
    /// 1. Host allocates input memory and writes data
    /// 2. Host allocates output length storage (4 bytes)
    /// 3. Host calls process() - component processes and allocates output
    /// 4. **Success**: Host reads output and cleans up all allocations
    /// 5. **Error**: Host checks error, cleans up input allocations only
    /// 
    /// ## Size Validation:
    /// - Input length must be ≤ MAX_PAYLOAD_SIZE (128MB)
    /// - Output length must be ≤ MAX_PAYLOAD_SIZE (128MB)
    /// - Zero-length inputs are valid and return zero-length outputs
    process: func(input-ptr: u32, input-len: u32, output-len-ptr: u32) -> result<u32, processing-error>;
    
    /// Allocate memory in WASM linear memory
    /// 
    /// Allocates a block of memory of the specified size and returns
    /// a pointer to the allocated memory. Used by the host to allocate
    /// memory for input data before calling process().
    /// 
    /// ## Current C-style equivalent:
    /// ```c
    /// void* allocate(uint32_t size);
    /// ```
    /// 
    /// ## Size Validation:
    /// - Size must be ≥ MIN_ALLOCATION_SIZE (1 byte)
    /// - Size must be ≤ MAX_ALLOCATION_SIZE (64MB)
    /// - Returns invalid-size error for out-of-bounds requests
    /// 
    /// ## Memory Safety:
    /// - Returns allocation-error on failure with specific error codes
    /// - Allocated memory is uninitialized (contains arbitrary data)
    /// - Caller must call deallocate() with exact size to prevent leaks
    /// - Multiple allocations are allowed but each needs separate deallocation
    allocate: func(size: u32) -> result<u32, allocation-error>;
    
    /// Deallocate memory in WASM linear memory
    /// 
    /// Frees a block of memory that was previously allocated by allocate().
    /// The pointer and size must exactly match a previous allocation.
    /// 
    /// ## Current C-style equivalent:
    /// ```c
    /// int deallocate(void* ptr, uint32_t size); // Returns 0 on success, error code on failure
    /// ```
    /// 
    /// ## Enhanced Memory Safety with Result:
    /// - **Validation**: Returns allocation-error instead of silent corruption
    /// - **Double-free Detection**: `invalid-pointer` error for already-freed memory
    /// - **Size Validation**: `size-mismatch` error if size doesn't match original allocation
    /// - **Multi-language Safety**: Error bubbling works cleanly in Go, Rust, etc.
    /// - **Debugging**: Specific error variants help identify memory management bugs
    /// 
    /// ## Error Cases:
    /// - `invalid-pointer(ptr)`: Pointer not from allocate() or already freed
    /// - `size-mismatch(expected)`: Size doesn't match, returns expected size
    /// - `memory-corruption`: Internal allocator state corrupted
    /// - **Success**: Freeing null pointer (0) returns Ok(()) safely
    deallocate: func(ptr: u32, size: u32) -> result<(), allocation-error>;
    
    /// Validation helper functions for size limits and error handling
    /// These functions help components validate inputs and map errors correctly
    
    /// Validate payload size against limits
    /// Returns true if size is within acceptable bounds for processing
    validate-payload-size: func(size: u32) -> bool;
    
    /// Validate allocation size against limits  
    /// Returns true if size is within acceptable bounds for allocation
    validate-allocation-size: func(size: u32) -> bool;
    
    /// Map allocation error to error code for Rust ProcessingNodeError conversion
    /// Returns error code that maps to appropriate ProcessingNodeError variant
    map-allocation-error: func(error: allocation-error) -> u32;
    
    /// Map processing error to error code for Rust ProcessingNodeError conversion
    /// Returns error code that maps to appropriate ProcessingNodeError variant
    map-processing-error: func(error: processing-error) -> u32;
}

/// World definition for DAGwood WASM components
/// 
/// This world defines the complete interface that DAGwood WASM components
/// must implement. It includes only the processing-node interface with no imports,
/// ensuring complete sandboxing and security isolation.
world dagwood-component {
    /// Export the processing-node interface
    /// 
    /// WASM components must export all functions in the processing-node interface:
    /// - process: Main data processing logic
    /// - allocate: Memory allocation for host-component communication
    /// - deallocate: Memory deallocation for cleanup
    export processing-node;
    
    /// No imports allowed for security
    /// 
    /// DAGwood WASM components deliberately import nothing to ensure
    /// complete sandboxing. This prevents access to:
    /// - Filesystem operations (WASI filesystem)
    /// - Network operations (WASI sockets)
    /// - System calls (WASI system interface)
    /// - Random number generation (WASI random)
    /// - Time/clock access (WASI clocks)
    /// 
    /// Components must be completely self-contained and deterministic.
}
