// Copyright (c) 2025 Steve Wagner (ciroque@live.com)
// SPDX-License-Identifier: MIT

/// DAGwood WASM Component Interface
/// 
/// This WIT file defines the WebAssembly Interface Types (WIT) specification
/// for DAGwood WASM components. These are low-level WASM modules that export
/// specific functions for data processing within the DAGwood pipeline system.
/// 
/// ## Architecture Overview
/// 
/// ```
/// DAGwood Runtime
///       ↓
/// WasmProcessor (Rust) ← implements Processor trait
///       ↓
/// WASM Component ← exports process(), allocate(), deallocate()
/// ```
/// 
/// The WASM component is a pure WASM module with no knowledge of DAGwood's
/// Processor trait. The WasmProcessor in the DAGwood runtime handles the
/// bridge between the Rust ecosystem and the WASM component.
/// 
/// ## Current Interface (C-style exports)
/// 
/// WASM components currently export three C-style functions:
/// - `process(input_ptr, input_len, output_len_ptr) -> output_ptr`
/// - `allocate(size) -> ptr`
/// - `deallocate(ptr, size)`
/// 
/// ## This WIT Specification
/// 
/// This WIT file provides a formal specification of the current interface:
/// - Documents the existing contract for implementors
/// - Enables tooling and binding generation
/// - Provides foundation for Component Model migration
/// - Maintains exact compatibility with current C-style exports
/// 
/// ## Future Evolution Path (vNext Component Model)
/// 
/// **Current v1.0**: Raw pointer interface optimized for C compatibility and host control
/// ```wit
/// process: func(input-ptr: u32, input-len: u32, output-len-ptr: u32) -> result<u32, processing-error>;
/// ```
/// 
/// **Future vNext**: Direct `list<u8>` interface reducing host boilerplate
/// ```wit
/// process: func(input: list<u8>) -> result<list<u8>, processing-error>;
/// ```
/// 
/// **Migration Benefits**:
/// - **Eliminates Host Boilerplate**: No manual allocate/memcpy/deallocate cycles
/// - **Type Safety**: Component Model handles memory management automatically
/// - **Multi-Language Ergonomics**: Natural `Vec<u8>` in Rust, `[]byte` in Go, etc.
/// - **Backward Compatibility**: Pointer-based components can coexist during transition
/// 
/// **Current Pointer Advantages** (why v1.0 is optimal for now):
/// - **C Ecosystem Compatibility**: Direct FFI with existing C/C++ WASM toolchains
/// - **Memory Control**: Host retains fine-grained control over allocation strategies
/// - **Debugging**: Explicit memory operations aid in troubleshooting
/// - **Performance**: Zero abstraction overhead for memory-sensitive workloads
/// 
/// ## Security Model
/// 
/// - **Complete Sandboxing**: No access to host filesystem, network, or system calls
/// - **Memory Isolation**: Components operate within bounded WASM linear memory
/// - **Resource Limits**: Execution time and memory consumption are bounded
/// - **Input Validation**: All inputs are validated before processing

package dagwood:component@1.0.0;

/// Low-level WASM component interface for data processing
/// 
/// This interface defines the contract for WASM components that process
/// data within DAGwood pipelines. Components are simple, stateless
/// processors that transform input data to output data.
interface processing-node {
    /// Size limits for WASM memory management
    /// These constants define the operational boundaries for safe WASM execution
    const MAX_PAYLOAD_SIZE: u32 = 134217728; // 128MB - reasonable limit for WASM linear memory
    const MAX_ALLOCATION_SIZE: u32 = 67108864; // 64MB - maximum single allocation
    const MIN_ALLOCATION_SIZE: u32 = 1; // Minimum allocation size
    
    /// Error codes for mapping to Rust ProcessingNodeError types
    const ERROR_CODE_VALIDATION: u32 = 1000;
    const ERROR_CODE_RUNTIME: u32 = 2000;
    const ERROR_CODE_INPUT: u32 = 3000;
    const ERROR_CODE_ALLOCATION: u32 = 4000;
    const ERROR_CODE_PROCESSING: u32 = 5000;

    /// Memory allocation errors with error codes for Rust mapping
    variant allocation-error {
        /// Out of memory - cannot allocate requested size
        /// Maps to ProcessingNodeError::CStyleError(AllocationFailed)
        out-of-memory,
        /// Invalid size - zero or excessively large allocation request
        /// Maps to ProcessingNodeError::ValidationError
        invalid-size(u32),
        /// Memory corruption - internal allocator state is corrupted
        /// Maps to ProcessingNodeError::RuntimeError
        memory-corruption,
        /// Invalid pointer - not from a previous allocate() call or already freed
        /// Maps to ProcessingNodeError::CStyleError(AllocationFailed)
        invalid-pointer(u32),
        /// Size mismatch - deallocate size doesn't match original allocation
        /// Maps to ProcessingNodeError::ValidationError
        size-mismatch(u32),
    }
    
    /// Data processing errors with error codes for Rust mapping
    variant processing-error {
        /// Invalid input data (malformed format, etc.)
        /// Maps to ProcessingNodeError::InputError
        /// Error strings ≤ 256 bytes to bound WASM memory; prefer concise codes like 'E001: Invalid header'
        invalid-input(string),
        /// Processing logic failed (algorithm error, computation failure)
        /// Maps to ProcessingNodeError::CStyleError(FunctionExecutionFailed)
        /// Error strings ≤ 256 bytes to bound WASM memory; prefer concise codes like 'E002: Algorithm failed'
        processing-failed(string),
        /// Input too large for component to handle
        /// Maps to ProcessingNodeError::ValidationError
        input-too-large(u32),
        /// Unknown/unexpected error for extensibility and opaque binary handling
        /// Maps to ProcessingNodeError::RuntimeError - catches weird formats gracefully
        /// Error strings ≤ 256 bytes to bound WASM memory; prefer concise codes like 'E999: Unknown format'
        unknown(string),
    }
    
    /// Main data processing function
    /// 
    /// Processes input data and returns a pointer to output data.
    /// This is a low-level interface that works directly with WASM linear memory.
    /// 
    /// ## Current C-style equivalent:
    /// ```c
    /// uint8_t* process(const uint8_t* input_ptr, uint32_t input_len, uint32_t *output_len);
    /// ```
    /// 
    /// ## Parameters:
    /// - `input-ptr`: Pointer to input data in WASM linear memory (u32 - WASM address space)
    ///   - **Alignment**: Naturally aligned to page boundaries (64KB) for optimal SIMD performance
    ///   - **Range**: Must be valid within WASM linear memory bounds
    /// - `input-len`: Length of input data in bytes (u32 - matches WASM 32-bit addressing)
    ///   - **Constraints**: Must be ≤ MAX_PAYLOAD_SIZE (128MB) as defined by constants
    ///   - **Validation**: Zero-length inputs are valid and should return zero-length outputs
    /// - `output-len-ptr`: Pointer to where output length should be written (u32)
    ///   - **Alignment**: 4-byte aligned for efficient i32 read/write operations
    ///   - **Usage**: Component writes output length here; host reads after process() returns
    /// 
    /// ## Returns:
    /// - **Success**: Pointer to allocated output data in WASM linear memory
    /// - **Error**: Returns processing-error with mapped error codes
    /// - Caller must call deallocate() to free the returned memory on success
    /// 
    /// ## Error Propagation & Debugging:
    /// - **Bindings Behavior**: Language bindings (Rust, etc.) map `Err` results to null pointer (0) + error logging
    /// - **Consistency Tip**: Components should write `*output-len-ptr = 0` on error for consistent host-side handling
    /// - **Rust Integration**: Errors chain cleanly with `?` operator in ProcessingNodeExecutor implementations
    /// - **Opaque Binary Safety**: Use `unknown(string)` for unexpected binary formats that can't be categorized
    /// 
    /// ## Simplified Memory Flow:
    /// 1. Host allocates input memory and writes data
    /// 2. Host allocates output length storage (4 bytes)
    /// 3. Host calls process() - component processes and allocates output
    /// 4. **Success**: Host reads output and cleans up all allocations
    /// 5. **Error**: Host checks error, cleans up input allocations only
    /// 
    /// ## Size Validation:
    /// - Input length must be ≤ MAX_PAYLOAD_SIZE (128MB)
    /// - Output length must be ≤ MAX_PAYLOAD_SIZE (128MB)
    /// - Zero-length inputs are valid and return zero-length outputs
    process: func(input-ptr: u32, input-len: u32, output-len-ptr: u32) -> result<u32, processing-error>;
    
    /// Allocate memory in WASM linear memory
    /// 
    /// Allocates a block of memory of the specified size and returns
    /// a pointer to the allocated memory. Used by the host to allocate
    /// memory for input data before calling process().
    /// 
    /// ## Current C-style equivalent:
    /// ```c
    /// void* allocate(uint32_t size);
    /// ```
    /// 
    /// ## Size Validation:
    /// - Size must be ≥ MIN_ALLOCATION_SIZE (1 byte)
    /// - Size must be ≤ MAX_ALLOCATION_SIZE (64MB)
    /// - Returns invalid-size error for out-of-bounds requests
    /// 
    /// ## Memory Safety:
    /// - Returns allocation-error on failure with specific error codes
    /// - Allocated memory is uninitialized (contains arbitrary data)
    /// - Caller must call deallocate() with exact size to prevent leaks
    /// - Multiple allocations are allowed but each needs separate deallocation
    allocate: func(size: u32) -> result<u32, allocation-error>;
    
    /// Deallocate memory in WASM linear memory
    /// 
    /// Frees a block of memory that was previously allocated by allocate().
    /// The pointer and size must exactly match a previous allocation.
    /// 
    /// ## Current C-style equivalent:
    /// ```c
    /// int deallocate(void* ptr, uint32_t size); // Returns 0 on success, error code on failure
    /// ```
    /// 
    /// ## Enhanced Memory Safety with Result:
    /// - **Validation**: Returns allocation-error instead of silent corruption
    /// - **Double-free Detection**: `invalid-pointer` error for already-freed memory
    /// - **Size Validation**: `size-mismatch` error if size doesn't match original allocation
    /// - **Multi-language Safety**: Error bubbling works cleanly in Go, Rust, etc.
    /// - **Debugging**: Specific error variants help identify memory management bugs
    /// 
    /// ## Error Cases:
    /// - `invalid-pointer(ptr)`: Pointer not from allocate() or already freed
    /// - `size-mismatch(expected)`: Size doesn't match, returns expected size
    /// - `memory-corruption`: Internal allocator state corrupted
    /// - **Success**: Freeing null pointer (0) returns Ok(()) safely
    deallocate: func(ptr: u32, size: u32) -> result<(), allocation-error>;
    
    /// Validation helper functions for size limits and error handling
    /// These functions help components validate inputs and map errors correctly
    
    /// Validate payload size against limits
    /// Returns true if size is within acceptable bounds for processing
    validate-payload-size: func(size: u32) -> bool;
    
    /// Validate allocation size against limits  
    /// Returns true if size is within acceptable bounds for allocation
    validate-allocation-size: func(size: u32) -> bool;
    
    /// Map allocation error to error code for Rust ProcessingNodeError conversion
    /// Returns error code that maps to appropriate ProcessingNodeError variant
    /// 
    /// ## Explicit Mappings:
    /// - `out-of-memory` → ERROR_CODE_ALLOCATION (4000) → ProcessingNodeError::CStyleError(AllocationFailed)
    /// - `invalid-size(size)` → ERROR_CODE_VALIDATION (1000) → ProcessingNodeError::ValidationError
    /// - `memory-corruption` → ERROR_CODE_RUNTIME (2000) → ProcessingNodeError::RuntimeError
    /// - `invalid-pointer(ptr)` → ERROR_CODE_ALLOCATION (4000) → ProcessingNodeError::CStyleError(AllocationFailed)
    /// - `size-mismatch(expected)` → ERROR_CODE_VALIDATION (1000) → ProcessingNodeError::ValidationError
    map-allocation-error: func(error: allocation-error) -> u32;
    
    /// Map processing error to error code for Rust ProcessingNodeError conversion
    /// Returns error code that maps to appropriate ProcessingNodeError variant
    /// 
    /// ## Explicit Mappings:
    /// - `invalid-input(msg)` → ERROR_CODE_INPUT (3000) → ProcessingNodeError::InputError
    /// - `processing-failed(msg)` → ERROR_CODE_PROCESSING (5000) → ProcessingNodeError::CStyleError(FunctionExecutionFailed)
    /// - `input-too-large(size)` → ERROR_CODE_VALIDATION (1000) → ProcessingNodeError::ValidationError
    /// - `unknown(msg)` → ERROR_CODE_RUNTIME (2000) → ProcessingNodeError::RuntimeError
    map-processing-error: func(error: processing-error) -> u32;
    
    /// Runtime compliance and tooling support
    
    /// Structured version information for programmatic compatibility checks
    record interface-version {
        /// Major version - incremented for breaking changes
        major: u32,
        /// Minor version - incremented for backward-compatible additions
        minor: u32,
        /// Patch version - incremented for backward-compatible fixes
        patch: u32,
    }
    
    /// Get component interface version for runtime compliance checks
    /// 
    /// Returns the WIT interface version this component implements as structured data.
    /// Enables efficient programmatic compatibility verification without string parsing.
    /// 
    /// ## Version Semantics:
    /// - **Breaking Changes**: Major version increments (1.x.x → 2.x.x)
    /// - **Compatible Additions**: Minor version increments (1.0.x → 1.1.x)
    /// - **Compatible Fixes**: Patch version increments (1.0.0 → 1.0.1)
    /// 
    /// ## Multi-Language Benefits:
    /// - **C Hosts**: Direct u32 comparison without strcmp overhead
    /// - **Rust Hosts**: Clean destructuring `let {major, minor, patch} = version()`
    /// - **Go Hosts**: Native struct comparison without version parsing
    /// - **Performance**: No atoi/string parsing in performance-critical loads
    /// 
    /// ## Usage Patterns:
    /// - **Host Verification**: `if version().major > 1 { return incompatible; }`
    /// - **Feature Detection**: `if version().minor >= 2 { use_new_feature(); }`
    /// - **Debugging**: Log structured version data for clear diagnostics
    /// - **Tooling Integration**: Automated compatibility matrices
    /// 
    /// ## Example Returns:
    /// - `{major: 1, minor: 0, patch: 0}` - Current interface version
    /// - `{major: 1, minor: 1, patch: 0}` - Added optional features (backward compatible)
    /// - `{major: 2, minor: 0, patch: 0}` - Breaking changes (requires host updates)
    version: func() -> interface-version;
}

/// World definition for DAGwood WASM components
/// 
/// This world defines the complete interface that DAGwood WASM components
/// must implement. It includes only the processing-node interface with no imports,
/// ensuring complete sandboxing and security isolation.
world dagwood-component {
    /// Export the processing-node interface
    /// 
    /// WASM components must export all functions in the processing-node interface:
    /// - process: Main data processing logic
    /// - allocate: Memory allocation for host-component communication
    /// - deallocate: Memory deallocation for cleanup
    export processing-node;
    
    /// No imports allowed for security
    /// 
    /// DAGwood WASM components deliberately import nothing to ensure
    /// complete sandboxing. This prevents access to:
    /// - Filesystem operations (WASI filesystem)
    /// - Network operations (WASI sockets)
    /// - System calls (WASI system interface)
    /// - Random number generation (WASI random)
    /// - Time/clock access (WASI clocks)
    /// 
    /// Components must be completely self-contained and deterministic.
}
